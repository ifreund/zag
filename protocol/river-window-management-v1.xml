<?xml version="1.0" encoding="UTF-8"?>
<protocol name="river_window_management_v1">
  <copyright>
    Copyright 2024 The River Developers

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
    SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
    OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
    CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  </copyright>

  <description summary="frame-perfect window management">
    This protocol allows a single "window manager" client to determine the
    window management policy of the compositor. State is globally
    double-buffered allowing for frame perfect state changes involving multiple
    windows.

    The key words "must", "must not", "required", "shall", "shall not",
    "should", "should not", "recommended", "may", and "optional" in this
    document are to be interpreted as described in IETF RFC 2119.

    Warning! The protocol described in this file is currently in the testing
    phase. Backward compatible changes may be added together with the
    corresponding interface version bump. Backward incompatible changes can only
    be done by creating a new major version of the extension.
  </description>

  <interface name="river_window_manager_v1" version="1">
    <description summary="window manager global interface">
      This global interface should only be advertised to the window manager
      process. Only one window management client may be active at a time. The
      compositor should use the unavailable event if necessary to enforce this.
    </description>

    <event name="unavailable">
      <description summary="window management unavailable">
        This event indicates that window management is not available to the
        client, perhaps due to another window management client already
        running. The circumstances causing this event to be sent are compositor
        policy.

        The server will send no further events on this object. The client should
        destroy this object and all objects created through this interface.
      </description>
    </event>

    <request name="stop">
      <description summary="stop sending events">
        This request indicates that the client no longer wishes to receive
        events on this object.

        The Wayland protocol is asynchronous, which means the server may send
        further events until the stop request is processed. The client must wait
        for a river_window_manager_v1.finished event before destroying this
        object.
      </description>
    </request>

    <event name="finished">
      <description summary="the server has finished with the window manager">
        This event indicates that the server will send no further events on this
        object. The client should destroy the object. See
        river_window_manager_v1.destroy for more information.
      </description>
    </event>

    <request name="destroy" type="destructor">
      <description summary="destroy the river_window_manager_v1 object">
        This request should be called after the finished event has been received
        to complete destruction of the object.

        If a client wishes to destroy this object it should send a
        river_window_manager_v1.stop request and wait for a
        river_window_manager_v1.finished event. Once the finished event is
        received it is safe to destroy this object and any other objects created
        through this interface.
      </description>
    </request>

    <event name="update">
      <description summary="all new state has been sent">
        This event is used to group state update events sent to the client into
        a single, atomic update.

        Since some state changes require action from the window manager client
        for frame perfection, the client should update the necessary state,
        ack_update, and commit as soon as possible on receiving an update event.

        For example, when the dimensions of a window change it may be necessary
        for the window manager to resize its decoration surfaces to match. In
        this case the compositor may wait for the window manager client to
        adjust the decoration surface size, ack_update, and commit before
        rendering the window at its new size to avoid imperfect frames where the
        decoration surface size does not match the window size.
      </description>
      <arg name="serial" type="uint"/>
    </event>

    <request name="ack_update">
      <description summary="ack an update event">
        If a client makes a river_window_manager_v1.commit request in response
        to a river_window_manager_v1.update event it must make an ack_update
        request before the commit request with the serial of that update event.

        If the client receives multiple update events before it can respond to
        one, only the most recent update event must be acked.

        A client may send multiple ack_update requests before committing. The
        last request sent before a commit indicates which update event the
        commit is in response to.

        It is a protocol error to issue multiple ack_update requests referencing
        the same update event or to issue an ack_update request referencing an
        update event older than the last update event acked.
      </description>
      <arg name="serial" type="uint"/>
    </request>

    <request name="commit">
      <description summary="commit double-buffered requested state">
        This request is used to group state update requests sent to the server
        into a single, atomic update.
      </description>
    </request>

    <event name="session_locked">
      <description summary="the session has been locked">
        This event indicates that the session has been locked.

        The window manager may wish to restrict which key bindings are available
        while locked or otherwise use this information.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <event name="session_unlocked">
      <description summary="the session has been unlocked">
        This event indicates that the session has been unlocked.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <event name="window">
      <description summary="new logical window">
        A new window has been created by some client.
      </description>
      <arg name="id" type="new_id" interface="river_window_v1"/>
    </event>

    <event name="output">
      <description summary="new logical output">
        A new logical output has been created, perhaps due to a new physical
        monitor being plugged in or perhaps due to a change in configuration.
      </description>
      <arg name="id" type="new_id" interface="river_output_v1"/>
    </event>

    <request name="get_seat">
      <description summary="get a seat extension object">
        Get the river_seat_v1 extension object for the given wl_seat.
      </description>
      <arg name="id" type="new_id" interface="river_seat_v1"/>
      <arg name="seat" type="object" interface="wl_seat"/>
    </request>

    <request name="get_shell_surface">
      <description summary="assign the river_shell_surface_v1 surface role">
        Create a new shell surface for window manager UI and assign the
        river_shell_surface_v1 role to the surface.

        Providing a wl_surface which already has a role or already has a buffer
        attached or committed is a protocol error.
      </description>
      <arg name="id" type="new_id" interface="river_shell_surface_v1"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>
  </interface>

  <interface name="river_window_v1" version="1">
    <description summary="a logical window">
      This represents a logical window. For example, a window may correspond to
      an xdg_toplevel or Xwayland window.

      A newly created window will not be displayed until the window manager
      proposes window dimensions (river_window_v1.propose_dimensions) and makes
      a river_window_manager_v1.commit request.

      The window manager should make this initial commit proposing dimensions
      for new windows as soon as possible after receiving the corresponding
      update event.

      TODO:
        - size hints (including unset state)
        - window cropping
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the window object">
        This request indicates that the client will no longer use the window
        object and that it may be safely destroyed.

        This request should be made by the client after the
        river_window_v1.closed event is received to complete destruction of the
        window.
      </description>
    </request>

    <event name="closed">
      <description summary="the window has been closed">
        The window has been closed by the server, perhaps due to an
        xdg_toplevel.close request or similar.

        The server will send no further events on this object and ignore any
        request other than river_window_v1.destroy made after this event is
        sent. The client should destroy this object with the
        river_window_v1.destroy request to free up resources.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <request name="close">
      <description summary="request that the window be closed">
        Request that the window be closed. The server will send a
        river_window_v1.closed event when the window has been closed and it is
        safe to destroy this object.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <request name="get_node">
      <description summary="get the window's render list node">
        Get the node in the render list corresponding to the window.

        It is a protocol error to make this request more than once for a single
        window.
      </description>
      <arg name="id" type="new_id" interface="river_node_v1"/>
    </request>

    <event name="dimensions">
      <description summary="window dimensions">
        This event indicates the dimensions of the window in the compositor's
        logical coordinate space. The width and height must be strictly greater
        than zero.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </event>

    <request name="propose_dimensions">
      <description summary="propose window dimensions">
        This request proposes dimensions for the window in the compositor's
        logical coordinate space.

        The width and height must be greater than or equal to zero. If the width
        or height is zero the window will be allowed to decide its own
        dimensions.

        The window may not take the exact dimensions proposed. The actual
        dimensions taken by the window will be sent in a subsequent
        river_window_v1.dimensions event. For example, a terminal emulator may
        only allow dimensions that are multiple of the cell size.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <request name="hide">
      <description summary="request that the window be hidden">
        Request that the window be hidden. Has no effect if the window is already
        hidden. Hides any window borders and decorations as well.

        Newly created windows are considered shown unless explicitly hidden with
        the hide request.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <request name="show">
      <description summary="request that the window be shown">
        Request that the window be shown. Has no effect if the window is not
        hidden. Does not guarantee that the window is visible as it may be
        completely obscured by other windows placed above it for example.

        Newly created windows are considered shown unless explicitly hidden with
        the hide request.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <event name="app_id">
      <description summary="the window set an application ID">
        The window set an application ID.

        This event may never be sent if the window never sets an application ID.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="app_id" type="string"/>
    </event>

    <event name="title">
      <description summary="the window set a title">
        The window set a title.

        This event may never be sent if the window never sets a title.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="title" type="string"/>
    </event>

    <event name="parent">
      <description summary="the window set a parent">
        The window set a parent window. If this event is never received or if
        the parent argument is null then the window has no parent.

        A surface with a parent set might be a dialog, file picker, or similar
        for the parent window.

        Child windows should generally be rendered directly above their parent.

        The compositor must guarantee that there are no loops in the window
        tree: a parent must not be the descendant of one of its children.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="parent" type="object" allow-null="true"
        interface="river_window_v1"/>
    </event>

    <enum name="decoration_hint">
      <entry name="only_supports_csd" value="0"
        summary="only supports client side decoration"/>
      <entry name="prefers_csd" value="1"
        summary="client side decoration preferred, both CSD and SSD supported"/>
      <entry name="prefers_ssd" value="2"
        summary="server side decoration preferred, both CSD and SSD supported"/>
      <entry name="no_preference" value="3"
        summary="no preference, both CSD and SSD supported"/>
    </enum>

    <event name="decoration_hint">
      <description summary="supported/preferred decoration style">
        Information from the window about the supported and preferred client
        side/server side decoration options.

        This event may be sent multiple times over the lifetime of the window if
        the window changes its preferences.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="hint" type="uint" enum="decoration_hint"/>
    </event>

    <request name="use_csd">
      <description summary="tell the client to use CSD">
        Tell the client to use client side decoration and draw its own title
        bar, borders, etc.

        This is the default if neither this request nor the use_ssd request is
        ever made.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <request name="use_ssd">
      <description summary="tell the client to use SSD">
        Tell the client to use server side decoration and not draw any client
        side decorations.

        This request will have no effect if the client only supports client side
        decoration, see the decoration_hint event.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <enum name="edges" bitfield="true">
      <entry name="none" value="0"/>
      <entry name="top" value="1"/>
      <entry name="bottom" value="2"/>
      <entry name="left" value="4"/>
      <entry name="right" value="8"/>
    </enum>

    <request name="set_borders">
      <description summary="set window borders">
        This request decorates the window with borders drawn by the compositor
        on the specified edges of the window. Borders are drawn above the window
        content.

        The color is defined by four 32-bit RGBA values. Unless specified in
        another protocol extension, the RGBA values use pre-multiplied alpha.

        Setting the edges to none or the width to 0 disables the borders.
        Setting a negative width is a protocol error.

        This request completely overrides all previous set_borders requests.
        Only the most recent set_borders request has an effect.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="edges" type="uint" enum="edges"/>
      <arg name="width" type="int"/>
      <arg name="r" type="uint"/>
      <arg name="g" type="uint"/>
      <arg name="b" type="uint"/>
      <arg name="a" type="uint"/>
    </request>

    <request name="set_tiled">
      <description summary="set window tiled state">
        Inform the window that it is part of a tiled layout and adjacent to
        other elements in the tiled layout on the given edges.

        The window should use this information to change the style of its client
        side decorations and avoid drawing e.g. drop shadows outside of the
        window dimensions on the tiled edges.

        Setting the edges argument to none informs the window that it is not
        part of a tiled layout. If this request is never made, the window is
        informed that it is not part of a tiled layout.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="edges" type="uint" enum="edges"/>
    </request>

    <request name="get_decoration_surface">
      <description summary="assign the river_decoration_v1 surface role">
        Create a window decoration surface for the window and assign the
        river_decoration_v1 role to the surface.

        Providing a wl_surface which already has a role or already has a buffer
        attached or committed is a protocol error.
      </description>
      <arg name="id" type="new_id" interface="river_decoration_v1"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <event name="pointer_move_requested">
      <description summary="the window requested interactive move">
        The xdg-shell protocol for example allows windows to request that an
        interactive move be started, perhaps when a client-side rendered
        titlebar is dragged.

        This event informs the window manager that the window has requested to
        be interactively moved using the pointer. The window manager is free to
        honor this request using river_seat_v1.pointer_move_window or ignore it.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <event name="pointer_resize_requested">
      <description summary="the window requested interactive resize">
        The xdg-shell protocol for example allows windows to request that an
        interactive resize be started, perhaps when the corner of client-side
        rendered decorations is dragged.

        This event informs the window manager that the window has requested to
        be interactively resized using the pointer. The window manager is free
        to honor this request using river_seat_v1.pointer_resize_window or
        ignore it.

        The edges argument indicates which edges the window has requested to be
        resized from. The edges argument will never be none and will never have
        both top and bottom or both left and right edges set.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="edges" type="uint" enum="edges"/>
    </event>

    <enum name="capabilities" bitfield="true">
      <entry name="window_menu" value="1"/>
      <entry name="maximize" value="2"/>
      <entry name="fullscreen" value="4"/>
      <entry name="minimize" value="8"/>
    </enum>

    <request name="set_capabilities">
      <description summary="inform window of supported capabilities">
        This request informs the window of the capabilities supported by the
        window manager. If the window manager, for example, ignores requests
        to be maximized from the window it should not tell the window that it
        supports the maximize capability.

        The window might use this information to, for example, only show a
        maximize button if the window manager supports the maximize capability.

        The window manager client should use this request to set capabilities
        for all new windows. If this request is never made, the compositor will
        inform windows that all capabilities are supported.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="caps" type="uint" enum="capabilities"/>
    </request>

    <event name="show_window_menu_requested">
      <description summary="window requested that the window menu be shown">
        The xdg-shell protocol for example allows windows to request that a
        window menu be shown, for example when the user right clicks on client
        side window decorations.

        A window menu might include options to maximize or minimize the window.

        The window manager is free to ignore this request and decide what the
        window menu contains if it does choose to show one.

        The x and y arguments indicate where the window requested that the
        window menu be shown.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="x" type="int" summary="x offset from top left corner"/>
      <arg name="y" type="int" summary="y offset from top left corner"/>
    </event>

    <event name="maximize_requested">
      <description summary="the window requested to be maximized">
        The xdg-shell protocol for example allows windows to request to be
        maximized.

        The window manager is free to honor this request using
        river_window_v1.inform_maximize or ignore it.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <event name="unmaximize_requested">
      <description summary="the window requested to be unmaximized">
        The xdg-shell protocol for example allows windows to request to be
        unmaximized.

        The window manager is free to honor this request using
        river_window_v1.inform_unmaximized or ignore it.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <request name="inform_maximized">
      <description summary="inform the window it is maximized">
        Inform the window that it is maximized. The window might use this
        information to adapt the style of its client-side window decorations for
        example.

        The window manager remains responsible for handling the position and
        dimensions of the window while it is maximized.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <request name="inform_unmaximized">
      <description summary="inform the window it is unmaximized">
        Inform the window that it is unmaximized. The window might use this
        information to adapt the style of its client-side window decorations for
        example.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <event name="fullscreen_requested">
      <description summary="the window requested to be fullscreen">
        The xdg-shell protocol for example allows windows to request that they
        be made fullscreen and allows them to provide an output preference.

        The window manager is free to honor this request using
        river_window_v1.set_fullscreen or ignore it.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="output" type="object" allow-null="true"
        interface="river_output_v1" />
    </event>

    <event name="exit_fullscreen_requested">
      <description summary="the window requested to exit fullscreen">
        The xdg-shell protocol for example allows windows to request to exit
        fullscreen.

        The window manager is free to honor this request using
        river_window_v1.unset_fullscreen or ignore it.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <request name="fullscreen">
      <description summary="make the window fullscreen">
        Make the window fullscreen on the given output. If multiple windows are
        fullscreen on the same output at the same time only the "top" window in
        rendering order shall be displayed.

        The compositor will handle the position and dimensions of the window
        while it is fullscreen. The set_position and propose_dimensions requests
        shall not affect the current position and dimensions of a fullscreen
        window.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="output" type="object" interface="river_output_v1"/>
    </request>

    <request name="exit_fullscreen">
      <description summary="make the window not fullscreen">
        Make the window not fullscreen.

        The new, post-fullscreen position and dimensions of the window will be
        determined by the most recent set_position and propose_dimensions
        requests.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <event name="minimize_requested">
      <description summary="the window requested to be minimized">
        The xdg-shell protocol for example allows windows to request to be
        minimized.

        The window manager is free to ignore this request, hide the window, or
        do whatever else it chooses.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>
  </interface>

  <interface name="river_decoration_v1" version="1">
    <description summary="a window decoration">
      This surface is rendered above the window's content and above the window's
      borders. The relative ordering of multiple decoration surfaces for the
      same window is undefined by this protocol and left up to the compositor.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the decoration object">
        This request indicates that the client will no longer use the decoration
        object and that it may be safely destroyed.
      </description>
    </request>

    <request name="set_offset">
      <description summary="set offset from the window's top left corner">
        This request sets the offset of the decoration surface from the top left
        corner of the window.

        If this request is never sent, the x and y offsets are undefined by this
        protocol and left up to the compositor.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <request name="sync_next_commit">
      <description summary="sync next surface commit to window manager commit">
        Synchronize application of the next wl_surface.commit request on the
        decoration surface with rest of the state atomically updated with the
        next river_window_manager_v1.commit request.

        The client must make a wl_surface.commit request on the decoration
        surface after this request and before the river_window_manager_v1.commit
        request, failure to do so is a protocol error.
      </description>
    </request>
  </interface>

  <interface name="river_shell_surface_v1" version="1">
    <description summary="a surface for window manager UI">
      The window manager might use a shell surface to display a status bar,
      background image, desktop notifications, launcher, desktop menu, or
      whatever else it wants.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the shell surface object">
        This request indicates that the client will no longer use the shell
        surface object and that it may be safely destroyed.
      </description>
    </request>

    <request name="get_node">
      <description summary="get the shell surface's render list node">
        Get the node in the render list corresponding to the shell surface.

        It is a protocol error to make this request more than once for a single
        shell surface.
      </description>
      <arg name="id" type="new_id" interface="river_node_v1"/>
    </request>

    <request name="sync_next_commit">
      <description summary="sync next surface commit to window manager commit">
        Synchronize application of the next wl_surface.commit request on the
        shell surface with rest of the state atomically updated with the next
        river_window_manager_v1.commit request.

        The client must make a wl_surface.commit request on the shell surface
        after this request and before the river_window_manager_v1.commit
        request, failure to do so is a protocol error.
      </description>
    </request>
  </interface>

  <interface name="river_node_v1" version="1">
    <description summary="a node in the render list">
      The render list is a list of nodes that determines the rendering order of
      the compositor. Nodes may correspond to windows or shell surfaces. The
      relative ordering of nodes may be changed with the place_above and
      place_below requests, changing the rendering order.

      The initial position of a node in the render list is undefined, the window
      manager client must use the place_above or place_below request to
      guarantee a specific rendering order.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the decoration object">
        This request indicates that the client will no longer use the node
        object and that it may be safely destroyed.
      </description>
    </request>

    <request name="set_position">
      <description summary="set absolute position of the node">
        Set the absolute position of the node in the compositor's logical
        coordinate space. The x and y coordinates may be positive or negative.

        If this request is never sent, the position of the node is undefined by
        this protocol and left up to the compositor.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <event name="position">
      <description summary="the absolute position of the node has changed">
        This event indicates the position of the node in the compositor's
        logical coordinate space. The x and y coordinates may be positive or
        negative.

        While the window manager client usually sets the position of the node,
        there are some cases in which the position must be modified by the
        server in which case this event is sent to inform the client of the new
        position. For example, this event is necessary to communicate the
        results of interactive resize to the window manager client.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </event>

    <request name="place_above">
      <description summary="place node above another node">
        This request places the node above another node in the scene graph.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="other" type="object" interface="river_node_v1"/>
    </request>

    <request name="place_below">
      <description summary="place node below another node">
        This request places the node below another node in the scene graph.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="other" type="object" interface="river_node_v1"/>
    </request>
  </interface>

  <interface name="river_output_v1" version="1">
    <description summary="a logical output">
      An area in the compositor's logical coordinate space that should be
      treated as a single output for window management purposes. This area may
      correspond to a single physical output or multiple physical outputs in the
      case of mirroring or tiled monitors depending on the hardware and
      compositor configuration.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the output object">
        This request indicates that the client will no longer use the output
        object and that it may be safely destroyed.

        This request should be made by the client after the
        river_output_v1.removed event is received to complete destruction of the
        output.
      </description>
    </request>

    <event name="removed">
      <description summary="the output is removed">
        This event indicates that logical output is no longer conceptually part
        of window management space.

        The server will send no further events on this object and ignore any
        request other than river_output_v1.destroy made after this event is
        sent. The client should destroy this object with the
        river_output_v1.destroy request to free up resources.

        This event may be sent because a corresponding physical output has been
        physically unplugged or because some output configuration has changed.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
    </event>

    <event name="position">
      <description summary="output position">
        This event indicates the position of the output in the compositor's
        logical coordinate space. The x and y coordinates may be positive or
        negative.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.

        The server must guarantee that the position and dimensions events do not
        cause the areas of multiple logical outputs to overlap when the
        corresponding river_window_manager_v1.update event is received.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </event>

    <event name="dimensions">
      <description summary="output dimensions">
        This event indicates the dimensions of the output in the compositor's
        logical coordinate space. The width and height will always be strictly
        greater than zero.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.

        The server must guarantee that the position and dimensions events do not
        cause the areas of multiple logical outputs to overlap when the
        corresponding river_window_manager_v1.update event is received.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </event>

    <event name="usable_area_hint">
      <description summary="output area intended for window management">
        This event indicates the area of the output that is intended for window
        management. This area may be smaller than the full dimensions of the
        output if there is, for example, a layer-shell client with an exclusive
        zone set (perhaps a status bar).

        The window manager is free to ignore this hint and place windows
        wherever it chooses.

        This area will always be equal to or smaller than the full area of the
        output. The x and y coordinates are relative to the output's position in
        the compositor's logical coordinate space and always greater than or
        equal to 0. The width and height are always strictly greater than zero
        and less than or equal to the output dimensions.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </event>
  </interface>

  <interface name="river_seat_v1" version="1">
    <description summary="a extension of wl_seat for window management">
      This object extends the wl_seat object with the features necessary for
      window management.

      TODO:
        - touch input
        - tablet input
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the seat object">
        This request indicates that the client will no longer use the seat
        object and that it may be safely destroyed.
      </description>
    </request>

    <request name="focus_window">
      <description summary="give keyboard focus to a window">
        Request that the compositor send keyboard input to the given window.

        Despite this request, the compositor may temporarily give keyboard focus
        to a wlr-layer-shell client requesting exclusive focus or similar if the
        compositor supports such a protocol. In such a case, the compositor
        should return focus to the specified window when the conditions that
        caused the window manager's request to be overruled no longer hold.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="window" type="object" interface="river_window_v1"/>
    </request>

    <request name="focus_shell_surface">
      <description summary="give keyboard focus to a shell_surface">
        Request that the compositor send keyboard input to the given shell
        surface.

        Despite this request, the compositor may temporarily give keyboard focus
        to a wlr-layer-shell client requesting exclusive focus or similar if the
        compositor supports such a protocol. In such a case, the compositor
        should return focus to the specified shell surface when the conditions
        that caused the window manager's request to be overruled no longer hold.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="shell_surface" type="object" interface="river_shell_surface_v1"/>
    </request>

    <request name="clear_focus">
      <description summary="clear keyboard focus">
        Request that the compositor not send keyboard input to any client.

        Despite this request, the compositor may temporarily give keyboard focus
        to a wlr-layer-shell client requesting exclusive focus or similar if the
        compositor supports such a protocol. In such a case, the compositor
        should again clear focus when the conditions that caused the window
        manager's request to be overruled no longer hold.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <event name="pointer_enter">
      <description summary="pointer entered a window">
        The seat's pointer entered the given window's area.

        The area of a window is defined to include the area defined by the
        window dimensions, borders configured using river_window_v1.set_borders,
        and the input regions of decoration surfaces. In particular, it does not
        include input regions of surfaces belonging to the window that extend
        outside the window dimensions.

        The pointer of a seat may only enter a single window at a time. When the
        pointer moves between windows, the pointer_leave event for the old
        window must be sent before the pointer_enter event for the new window.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="window" type="object" interface="river_window_v1"/>
    </event>

    <event name="pointer_leave">
      <description summary="pointer left a window">
        The seat's pointer left the given window. See pointer_enter for details.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="window" type="object" interface="river_window_v1"/>
    </event>

    <event name="pointer_motion">
      <description summary="pointer moved">
        The seat's pointer moved. The x and y coordinates are in the
        compositor's logical coordinate space.

        Rationale: pointer motion events in some form are necessary to implement
        the "always" style of focus-follows-cursor. Choosing to expose global
        pointer position/motion information to the window manager rather than
        motion events relative to a window allows other potentially interesting
        features, for example hot corners.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </event>

    <event name="window_interaction">
      <description summary="a window has been interacted with">
        A window has been interacted with beyond the pointer merely passing over
        it. This event might be sent due to a pointer button press or due to a
        touch/tablet tool interaction with the window.

        There are no guarantees regarding how this event is sent in relation to
        the pointer_enter and pointer_leave events as the interaction may use
        touch or tablet tool input.

        Rationale: this event gives window managers necessary information to
        determine when to send keyboard focus, raise a window that already has
        keyboard focus, etc. Rather than expose all pointer, touch, and tablet
        events to window managers, a policy over mechanism approach is taken.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.
      </description>
      <arg name="window" type="object" interface="river_window_v1"/>
    </event>

    <request name="pointer_move_window">
      <description summary="start interactive pointer move of a window">
        This request causes the position of a window to be updated while the
        pointer is moved. Multiple windows may be interactively moved at the same
        time.

        The interactive move is ended when all pointer buttons are released.
        This request is ignored if no pointer buttons are held.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="window" type="object" interface="river_window_v1"/>
    </request>

    <request name="pointer_resize_window">
      <description summary="start interactive pointer resize of a window">
        This request causes the a window to be resized from the specified edges,
        updating the position/dimensions of the window as the pointer is moved.
        Multiple windows may be interactively resized at the same time.

        The interactive resize is ended when all pointer buttons are released.
        This request is ignored if no pointer buttons are held.

        It is a protocol error to set the edges argument to none. It is also an
        error to set both the top and bottom edges or both the left and right
        edges. Resizing from, for example, both the top and right edges is
        allowed.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="window" type="object" interface="river_window_v1"/>
      <arg name="edges" type="uint" enum="river_window_v1.edges"/>
    </request>

    <request name="pointer_confine_to_region">
      <description summary="prevent the pointer from leaving a region">
        This request tells the compositor to confine the movement of the pointer
        to a given region, preventing movement of the input device from moving
        the pointer outside the region. In addition, the pointer continues to be
        confined to the bounds of the outputs.

        If the pointer is not inside the given region when this request is made
        it will have no effect until the pointer is moved inside the region.

        If the pointer is warped to a point outside of the region it will
        (temporarily) escape confinement. Moving or warping the pointer back
        inside the region will resume the confinement.

        If the region argument is null the compositor will only confine the
        cursor to the bounds of the outputs. This is also the behavior if this
        request is never made.

        The region is defined in the compositor's logical coordinate space.

        This request may be useful to place bounds on an interactive pointer
        move or resize for example.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="region" type="object" allow-null="true" interface="wl_region"/>
    </request>

    <request name="pointer_warp">
      <description summary="warp the pointer to a given position">
        Warp the pointer to the given position in the compositor's logical
        coordinate space.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <enum name="modifiers" bitfield="true">
      <description summary="a set of keyboard modifiers">
        This enum is used to describe the keyboard modifiers that must be held
        down to trigger a key binding or pointer binding.

        Note that river and wlroots use the values 2 and 16 for capslock and
        numlock internally. It doesn't make sense to use locked modifiers for
        bindings however so these values are not included in this enum.
      </description>
      <entry name="none" value="0"/>
      <entry name="shift" value="1"/>
      <entry name="ctrl" value="4"/>
      <entry name="mod1" value="8" summary="commonly called alt"/>
      <entry name="mod3" value="32"/>
      <entry name="mod4" value="64" summary="commonly called super or logo"/>
      <entry name="mod5" value="128"/>
    </enum>

    <request name="define_xkb_binding">
      <description summary="define a new xkbcommon key binding">
        Define a key binding in terms of an xkbcommon keysym and other
        configurable properties.

        The new key binding is not enabled until initial configuration is
        completed, the enable request is made, and the change is committed with
        a river_window_manager_v1.commit request.
      </description>
      <arg name="id" type="new_id" interface="river_xkb_binding_v1"/>
      <arg name="keysym" type="uint" summary="an xkbcommon keysym"/>
      <arg name="modifiers" type="uint" enum="modifiers"/>
    </request>

    <request name="define_pointer_binding">
      <description summary="define a new pointer binding">
        Define a pointer binding in terms of a pointer button, modifiers, and
        other configurable properties.

        The button argument is a Linux input event code defined in the
        linux/input-event-codes.h header file (e.g. BTN_RIGHT).

        The new key binding is not enabled until initial configuration is
        completed, the enable request is made, and the change is committed with
        a river_window_manager_v1.commit request.
      </description>
      <arg name="id" type="new_id" interface="river_pointer_binding_v1"/>
      <arg name="button" type="uint" summary="a Linux input event code"/>
      <arg name="modifiers" type="uint" enum="modifiers"/>
    </request>
  </interface>

  <interface name="river_xkb_binding_v1" version="1">
    <description summary="configure a xkb key binding, receive trigger events">
      This object allows the window manager to configure a xkbcommon key binding
      and receive events when the key binding is triggered.

      The new key binding is not enabled until initial configuration is
      completed, the enable request is made, and the change is committed with a
      river_window_manager_v1.commit request.

      Normally, all key events are sent to the surface with keyboard focus by
      the compositor. Key events that trigger a key binding are not sent to the
      surface with keyboard focus.

      If multiple key bindings would be triggered by a single physical key event
      on the compositor side, it is compositor policy which key binding(s) will
      receive press/release events or if all of the matched key bindings receive
      press/release events.

      Key bindings might be matched by the same physical key event due to shared
      keysym and modifiers. The layout override feature may also cause the same
      physical key event to trigger two key bindings with different keysyms and
      different layout overrides configured.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the xkb binding object">
        This request indicates that the client will no longer use the xkb key
        binding object and that it may be safely destroyed.
      </description>
    </request>

    <request name="set_layout_override">
      <description summary="override currently active xkb layout">
        Specify an xkb layout that should be used to translate key events for
        the purpose of triggering this key binding irrespective of the currently
        active xkb layout.

        The layout argument is a 0-indexed xkbcommon layout number for the
        keyboard that generated the key event.

        If this request is not made before the enable request the currently
        active xkb layout of the keyboard that generated the key event will be
        used.

        It is a protocol error to make this request after the first enable
        request.
      </description>
      <arg name="layout" type="uint" summary="0-indexed xkbcommon layout"/>
    </request>

    <request name="enable">
      <description summary="enable the key binding">
        This request should be made after all initial configuration has been
        completed and the window manager wishes the key binding to be able to be
        triggered.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <request name="disable">
      <description summary="disable the key binding">
        This request may be used to temporarily disable the key binding. It may
        be later re-enabled with the enable request.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <event name="pressed">
      <description summary="the key triggering the binding has been pressed">
        This event indicates that the physical key triggering the binding has
        been pressed.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.

        The compositor should wait for the window manager to ack the update and
        commit in response before processing further input events. This allows
        the window manager client to, for example, modify key bindings and
        keyboard focus without racing against future input events. The window
        manager should ack and commit as soon as possible as the capacity of the
        compositor to buffer incoming input events is finite.
      </description>
    </event>

    <event name="released">
      <description summary="the key triggering the binding has been released">
        This event indicates that the physical key triggering the binding has
        been released.

        Releasing the modifiers for the binding without releasing the "main"
        physical key that produces the bound keysym does not trigger the release
        event. This event is not sent until the "main" key is released.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.

        The compositor should wait for the window manager to ack the update and
        commit in response before processing further input events. This allows
        the window manager client to, for example, modify key bindings and
        keyboard focus without racing against future input events. The window
        manager should ack and commit as soon as possible as the capacity of the
        compositor to buffer incoming input events is finite.
      </description>
    </event>
  </interface>

  <interface name="river_pointer_binding_v1" version="1">
    <description summary="configure a pointer binding, receive trigger events">
      This object allows the window manager to configure a pointer binding and
      receive events when the binding is triggered.

      The new pointer binding is not enabled until initial configuration is
      completed, the enable request is made, and the change is committed with a
      river_window_manager_v1.commit request.

      Normally, all pointer button events are sent to the surface with pointer
      focus by the compositor. Pointer button events that trigger a pointer
      binding are not sent to the surface with pointer focus.

      If multiple pointer bindings would be triggered by a single physical
      pointer event on the compositor side, it is compositor policy which
      pointer binding(s) will receive press/release events or if all of the
      matched pointer bindings receive press/release events.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the pointer binding object">
        This request indicates that the client will no longer use the pointer
        binding object and that it may be safely destroyed.
      </description>
    </request>

    <request name="enable">
      <description summary="enable the pointer binding">
        This request should be made after all initial configuration has been
        completed and the window manager wishes the pointer binding to be able
        to be triggered.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <request name="disable">
      <description summary="disable the pointer binding">
        This request may be used to temporarily disable the pointer binding. It
        may be later re-enabled with the enable request.

        This request is double-buffered state and will not be applied until the
        next river_window_manager_v1.commit request.
      </description>
    </request>

    <event name="pressed">
      <description summary="the bound pointer button has been pressed">
        This event indicates that the pointer button triggering the binding has
        been pressed.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.

        The compositor should wait for the window manager to ack the update and
        commit in response before processing further input events. This allows
        the window manager client to, for example, modify pointer bindings
        without racing against future input events. The window manager should
        ack and commit as soon as possible as the capacity of the compositor to
        buffer incoming input events is finite.
      </description>
    </event>

    <event name="released">
      <description summary="the bound pointer button has been released">
        This event indicates that the pointer button triggering the binding has
        been released.

        Releasing the modifiers for the binding without releasing the pointer
        button does not trigger the release event. This event is not sent until
        the pointer button is released.

        This event is double-buffered state and will be followed by a
        river_window_manager_v1.update event.

        The compositor should wait for the window manager to ack the update and
        commit in response before processing further input events. This allows
        the window manager client to, for example, modify pointer bindings
        without racing against future input events. The window manager should
        ack and commit as soon as possible as the capacity of the compositor to
        buffer incoming input events is finite.
      </description>
    </event>
  </interface>
</protocol>
